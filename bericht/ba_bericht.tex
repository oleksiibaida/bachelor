\documentclass[12pt, letterpaper]{article}
\usepackage[ngerman]{babel}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{titlesec}
\usepackage{geometry}
\usepackage[font=scriptsize]{caption}
\usepackage{blindtext}
\usepackage{hyperref}
\usepackage{tabularx}
\usepackage{subcaption}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{multirow}
\usepackage{array} % Für die Spaltenbreitenanpassung
\usepackage{booktabs} % Für schönere Tabellen
\usepackage{geometry}
\usepackage{arydshln}
\usepackage{colortbl}
\usepackage{forest}
\usepackage{caption}
\usepackage{pifont}
\usepackage{amssymb}
\usepackage{enumitem}
\renewcommand{\lstlistlistingname}{Programmcode}

\geometry{a4paper, margin=2cm}
\hypersetup{
  colorlinks = true,
  linkcolor = black,
  urlcolor = blue,
}

% \captionsetup{justification=raggedright,singlelinecheck=false}
\geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 }
%  \titleformat{\section}[display]
%    {\normalfont\bfseries}{}{0pt}{\huge}

\lstdefinestyle{py}{
    language=Python,
    backgroundcolor=\color{white},
    keywordstyle=\color{blue}\bfseries,        % Default Python keywords
    commentstyle=\color{brown}\bfseries,         % Comments
    stringstyle=\color{brown},                 % Strings
    numberstyle=\tiny\color{gray},             % Line numbers
    basicstyle=\ttfamily\small,                % Base font
    identifierstyle=\color{black},             % Default for variable names
    keywordstyle=[2]\color{cyan},              % Functions
    keywordstyle=[3]\color{purple},            % Types
    breaklines=true,
    showstringspaces=false,
    tabsize=4,
    captionpos=b,
    %numbers=left,
    %numbersep=10pt,
    frame=single
}

% Define specific keywords
\lstset{
    morekeywords={import, from, def, return},  % Default Python keywords
    morekeywords=[2]{print, println, len, range, input}, % Functions
    morekeywords=[3]{int, float, str, list, dict, bool} % Types
}


\lstdefinestyle{cpp}{
    language=C,
    backgroundcolor=\color{white},
    keywordstyle=\color{blue}\bfseries,        % Standard Keywords
    commentstyle=\color{green}\itshape,        % Kommentare
    stringstyle=\color{orange},                % Strings
    numberstyle=\tiny\color{gray},             % Zeilennummern
    basicstyle=\ttfamily\small,                % Basis-Schriftart
    identifierstyle=\color{black},             % Standard für Variablennamen
    keywordstyle=[2]\color{cyan},              % Funktionen
    keywordstyle=[3]\color{purple},            % Typen
    breaklines=true,
    showstringspaces=false,
    tabsize=4,
    captionpos=b,
    %numbers=left,
    %numbersep=10pt,
    frame=single
}

% Spezifische Keywords definieren
\lstset{
    morekeywords={if, else, while, return},         % Standard C-Keywords
    morekeywords=[2]{printf, scanf, main, malloc},  % Funktionen (inkl. malloc)
    morekeywords=[3]{int, float, char, double}      % Typen
}

%\lstset{style=pycharm-light}

  
\usepackage{lipsum}  
\graphicspath{ {./Bilder/} }
\author{Oleksii Baida}
\date{Mai 2024}
\begin{document}
\include{titelseite}

\tableofcontents
\pagebreak

\section{Einleitung}
\par In einer Welt, die zunehmend von vernetzten Geräten und dem Internet der Dinge geprägt ist, wird die Entwicklung effizienter und benutzerfreundlicher Systeme zur Steuerung und Überwachung von Gebäuden immer relevanter. Im Jahr 2024 wurde in Deutschland die Anzahl von über 19 Millionen Haushalten, die ein oder mehrere smarte Geräte besaßen, verzeichnet. Es wird prognostiziert, dass sich diese Zahl innerhalb der nächsten drei Jahre verdoppeln wird \cite{statita_smhomes}.
\par Moderne Steuerungs- und Sicherheitssysteme tragen zur Effizienzsteigerung und Ressourcenschonung bei. Laut Günther Ohland, Vorstandsmitglied des Branchenverbands "Smarthome Initiative Deutschland", ermöglichen diese Systeme eine Reduktion des Heizenergieverbrauchs um 20 bis 30 Prozent \cite{spiegel_heizung}. Die Kosten für die smarte Technik rechnen sich in der Regel nach zwei Jahren. Die Systeme übernehmen ein Teil der täglichen Aufgaben, wie das Ein- und Ausschalten des Lichts, die Reglung der Raumtemperatur oder das Aufräumen des Hauses etc. Der Aufgabenbereich der Systeme ist dabei nur nach den Bedürfnissen der Benutzerinnen und Benutzer abgegrenzt.
\par Im Rahmen meiner Bachelorarbeit wird ein System zur Steuerung und Überwachung des Hauses entwickelt. Das Ziel dieser Arbeit ist die Erstellung einer Schnittstelle, die die Interaktion des Benutzers mit den Geräten in seinem Haushalt ermöglicht und den Benutzer über gefährliche Vorgänge in seinem Haus informiert. 
\par Im Rahmen der Entwicklung dieses Systems wurden die aktuellen Technologien zur Erstellung eines Webinterfaces und zur Kommunikation zwischen den Geräten eingesetzt. \textbf{TODO Kurz erklären was in Kapitel 2,3,4,5 ... erklärt wird}

\newpage
\section{Grundlagen \& Theorie}
\par In diesem Abschnitt erfolgt die detaillierte Darstellung der technischen Informationen zu den verwendeten Komponenten und Technologien. 
  \subsection{Hardware}
    \subsubsection{Arduino}
    \subsubsection{ESP8266}
    \subsubsection{Raspberry Pi}
    \subsubsection{ESP32}
    \subsubsection{M5Stick}
    \subsubsection{BME680}
    \subsubsection{VCNL}
    

  \subsection{Kommunikationsprotokolle}
  \subsubsection{HTTP}
  \subsubsection{MQTT}
  \subsubsection{UART}
  \subsubsection{I2C}
    
  \subsection{Software}
  \subsubsection{PlatformIO}
    \subsubsection{Asyncio}
    \subsubsection{FastAPI}
    \subsubsection{SQLAlchemy}
    \subsubsection{Uvicorn}
    \subsubsection{HTML \& TailwindCSS}
    \subsubsection{Javascript}
    \subsubsection{WebSocket}
    \subsubsection{Linux-Pakete für Raspberry Pi}

\newpage
\section{Konzeption das Systems}
\par Im Rahmen dieses Projektes wurde ein System entwickelt, welches die Funktionalitäten eines Kontroll- und Verwaltungssystems mit denen eines IoT-Systems vereint. Die Integration von Sensordaten und Benutzerinteraktionen stellt einen wesentlichen Aspekt des Systems dar. Die Realisierung erfolgt durch die Kombination verschiedener Technologien und Teilsysteme, darunter eine Webanwendung auf FastAPI, eine MQTT-Kommunikationsschicht und verschiedene Aktoren und Sensoren, die auf Arduino- oder ESP-Module basieren.

\subsection{Komponenten des Systems}
\par Das entwickelte System basiert auf einer modularen Architektur, die mehrere Komponenten integriert. Jede dieser Komponenten erfüllt eine spezifische Rolle im Gesamtsystem: 
\begin{itemize} 
  \item \textbf{Raspberry Pi:} Der zentrale Server, der das lokale WLAN-Netzwerk bereitstellt, den MQTT-Broker hostet und die Webanwendung ausführt. 
  \item \textbf{Arduino:} Ausgestattet mit mehreren Sensoren, die Gefahren wie Feuer und Gas erkennen und den Zugang zum Haus sichern. Entsprechende Meldungen werden an den Server gesendet.
  \item \textbf{M5Stick:} Angeschlossen an die Temperatur- und Lichtsensoren und sendet die aufgezeichneten Daten auf den Server. 
  \item \textbf{ESP32:} TTTOOOOODDDDOOOO 
  \item \textbf{Webserver:} Eine auf FastAPI basierende RESTful API, die Benutzern den Zugriff auf das System und die Steuerung von Geräten ermöglicht. 
  \item \textbf{Datenbank:} Eine lokale Datenbank zur Speicherung von Benutzerinformationen und Gerätekonfigurationen.
  \item \textbf{Web-Anwendung:} Eine browserbasierte Benutzeroberfläche, die den Benutzern eine intuitive Steuerung und Visualisierung der Daten ermöglicht. 
\end{itemize}

\subsection{Architektur und Datenfluss}
\par Der Raspberry Pi dient als zentraler Server des Systems. Der Minicomputer stellt ein WLAN-Netzwerk zur Verfügung und hostet den Webserver mit der Datenbank sowie den MQTT-Broker. Alle Benutzerinteraktionen, Sensordaten, Datenflüsse und Datenverarbeitungen finden auf dem Server statt. Somit ist das System stark zentralisiert. Das System ist somit stark zentralisiert und arbeitet nur lokal. Das bedeutet, dass sich alle Benutzer in einem lokalen Netzwerk mit dem Raspberry Pi befinden müssen. 
\par Die Geräte verbinden sich mit dem WLAN, das vom Raspberry Pi zur Verfügung gestellt wird. Die Sensoren senden ihre Daten an den MQTT-Broker, der auf dem Raspberry Pi läuft. Die Aktoren abonnieren die Command-Topics mit der entsprechenden "Geräte-ID".
\par Im Kern des Systems befindet sich ein Webserver, der auf dem Raspberry Pi ausgeführt wird. Dieser Webserver stellt eine RESTful-API zur Verfügung. Für den Zugriff zu der API wurde eine Webseite aufgebaut. Die API bietet folgende Funktionen an:
\begin{itemize}
  \item Authentifizierung und Autorisierung der Benutzer
  \item Verwaltung der Gerätekonfigurationen und Benutzerprofile
  \item Bereitstellung von Endpunkten zur Abfrage und Steuerung von IoT-Geräten
  \item Bidirektionale Kommunikation mit den IoT-Geräten
\end{itemize}
\par Die Benutzerdaten und Konfigurationen werden in der lokalen Datenbank auf dem Server gespeichert. 
\par 
\newpage
\section{Implementierung und praktische Umsetzung}
\subsection{Einrichtung der Hardwarekomponenten}
  \subsubsection{Arduino}
  \par Der Arduino mit den angeschlossenen Sensoren stellt das Sichterheitskomponente des Systems dar. Dieses Teilsystem erkennt die Gefahren von Gas und Feuer und alarmiert den Benutzer. Außerdem stellt der Arduino der gesicherte Zugang zu dem Haus durch die Eingabe einer PIN. Die Anschließung der Sensoren und Aktoren an Arduino ist in der PA1 \cite{pa1} beschrieben. 
  \par Der Arduino kann nicht direkt mit einem WLAN verbunden werden, da er kein WLAN-Modul besitzt. Für diesen Zweck habe ich ein ESP8266-Modul verwendet. Der wird mit dem Arduino durch eine UART-Schnittstelle angeschlossenen und mit dem WLAN verbunden. Die Kommunikation zwischen Arduino und ESP8266 erfolgt über die serielle Schnittstelle. Der Arduino gibt die entsprechenden Kommanden durch Serial an ESP8266 weiter und der ESP8266 führt die Befehle aus. Die detaillierte Beschreibung zur Verbindung von Arduino und ESP8266 ist in dem Bericht zu meiner Projektarbeit 2 \cite{pa2} Kapitel 4.1 zu finden.
  \par Der Arduino sendet und empfängt die MQTT-Nachrichten via ESP8266. Ein Mal pro Sekunde sendet der Arduino eine MQTT-Nachricht in das Topic "status/<ID>/" in dem die Bereitschaft der angeschlossenen Sensoren geteilt wird. Bei der Erkennung einer Gefahr wird sofort der Alarm ausgelöst und eine MQTT-Nachricht in das Topic "alarm/<ID>" mit dem entsprechenden Text gesendet.
  \subsubsection{Raspberry Pi}
  \subsubsection{Setup der ESP-Module}
  \par In diesem Projekt werden drei verschiedene ESP-Module verwendet: ESP8266, ESP32 und der auf dem ESP32 basierende M5Stick.  Jedes Modul erfüllt spezifische Aufgaben, aber alle Module müssen sowohl mit dem WLAN als auch mit dem MQTT-Broker verbunden sein. Daher ist die Implementierung der Funktion \texttt{setup()} für alle drei Module ähnlich aufgebaut.
  \par Beim Start des ESP-Moduls wird die Funktion \texttt{setup()} (Listing \ref{lst:esp8266setup}) aufgerufen. Zunächst wird es versucht, die WLAN-Zugangsdaten aus dem EEPROM auszulesen (Zeile 5-10). Das EEPROM wird mit einer Größe von 128 Byte initialisiert. Dies ist notwendig, bevor Daten aus dem Speicher gelesen werden können. Es werden zwei Felder vom Typ \texttt{char} wurden mit den in den eckigen Klammern angegebenen Längen erstellt (Zeile 6-7), um die aus dem EEPROM gelesenen Daten zu speichern. Beide Felder sind zunächst mit Nullen gefüllt. Der Name des WLAN-Netzes (SSID) wird ab Adresse 0 des EEPROM ausgelesen und mit der Funktion \texttt{EEPROM.get(0, eeprom\_ssid)} im Char-Feld gespeichert. Das Passwort wird ab Adresse 32 aus dem EEPROM ausgelesen.
  \par Anschließend prft die Boolean-Funktion \texttt{is\_valid\_string()} (Listing \ref{lst:esp8266validstring}), ob der übergebene String-Parameter eine Länge größer als 0 und kleiner als \texttt{max\_length}, sowie eine korrekte Terminierung hat. Zusätzlich gibt die Funktion den Wert \texttt{False} zurück, wenn der String ein Standard-EEPROM-Zeichen mit dem Wert \texttt{0xFF} enthält.
  \par Sind die gültigen Werte im EEPROM gespeichert, versucht das Modul, sich mit diesen Zugangsdaten mit dem WLAN zu verbinden (Zeile 14). Die Funktion \texttt{connect\_wifi} (Listing \ref{lst:espconnectwifi}) schaltet das WLAN-Modul in den Modus "Station" um, was die Verbindung mit anderen WLAN-Netzwerken erlaubt. Danach wird es versucht mit dem WLAN mit übergebenen Zugangsdaten zu verbinden. In der Variable \texttt{wifi\_repeat} ist die Anzahl der Versuche zur Erstellung der Verbindung gespeichert. Jede Sekunde wird den Status der Verbindung überprüft. Wenn die Verbindung erfolgreich erstellt wurde, gibt die Funktion \texttt{True} aus. 
  \par Nach erfolgreicher Verbindung mit dem WLAN, wird die Funktion \texttt{connect\_mqtt} (Listing \ref{lst:espconnectmqtt}) aufgerufen. Zunächst wird die Funktion \texttt{set\_topics} aufgerufen, die die Topics zum Senden und Empfangen der Nachrichten erstellt. Dabei werden die Topics mit \texttt{DEVICE\_ID} für jedes Gerät individuell formuliert. Der \texttt{mqttClient} ist ein Objekt der Klasse \texttt{PubSubClient}. Die Funktion \texttt{setServer()} erhält als Parameter die IP-Adresse des MQTT-Brokers sowie den Port, auf dem der Broker lauscht. Diese Parameter sind als Konstanten definiert. Die Callback-Funktion wird beim Empfang einer MQTT-Nachricht ausgeführt und ist für jedes Modul unterschiedlich aufgebaut. Anschließend verbindet sich das Modul mit dem MQTT-Broker und abonniert das \texttt{SUBSCRIBE\_TOPIC}.
  \par Falls die aus dem EEPROM ausgelesenen Daten ungültig sind oder keine erfolgreiche WLAN-Verbindung aufgebaut werden kann, wird die Funktion setup\_ap() (Listing \ref{lst:esp8266setupap}) aufgerufen. Diese Funktion versetzt das WLAN-Modul in den Modus „Access Point“ und stellt einen Webserver bereit. Die Konfiguration des Access Points erfolgt über die Befehle WiFi.softAP() und WiFi.softAPConfig(), wobei die Parameter des Access Points in Listing \ref{lst:esp8266defap} definiert sind. 
  \par Der Webserver wird durch das Objekt \texttt{server} der Klasse \texttt{AsyncWebServer} zur Verfügung gestellt. Der Webserver wird mit dem Befehl \texttt{server.begin()} gestartet. Die HTTP-Route wird innerhalb der Funktion server.on() festgelegt. Beim Aufruf der Root-Route ("/") wird eine HTTP-GET-Anfrage bearbeitet, die mit einer HTML-Seite beantwortet wird. Diese Seite, deren Inhalt in der Variablen \texttt{html\_page} (Listing \ref{lst:esp8266defap}) gespeichert ist, enthält ein Formular zur Eingabe der WLAN-Zugangsdaten.
  \par Wenn der Benutzer auf die Taste „Submit“ drückt, wird eine HTTP-POST-Anfrage an den Server gesendet. Die Zugangsdaten werden aus dem request-Objekt ausgelesen und auf ihre maximale Länge überprüft. Wenn die Daten gültig sind, werden sie im EEPROM gespeichert. Der EEPROM wird initialisiert, die neuen Zugangsdaten werden gespeichert, und die Änderungen mit \texttt{EEPROM.commit()} übernommen. Anschließend wird das ESP-Modul mit \texttt{ESP.restart()} neu gestartet, um die neuen WLAN-Daten zu verwenden.
  \par Diese Setup-Konfiguration wird bei allen ESP-Modulen verwendet. Je nach Modul kann diese Funktion erweitert sein. Beispielsweise wird bei Modulen mit Display angezeigt, ob die Verbindung aufgebaut wurde.
\begin{lstlisting}[frame=single, style=cpp, numbers=left, label={lst:esp8266setup}, caption={ESP: setup}]
  void setup()
  {
    Serial.begin(9600);
    // GET WiFi Daten aus EEPROM
    EEPROM.begin(128);
    char eeprom_ssid[MAX_SSID_LENGTH] = {0};
    char eeprom_password[MAX_PASSWORD_LENGTH] = {0};
    EEPROM.get(0, eeprom_ssid);
    EEPROM.get(32, eeprom_password);
    EEPROM.end();
    // Daten gefunden
    if (is_valid_string(eeprom_ssid, MAX_SSID_LENGTH) && is_valid_string(eeprom_password, MAX_PASSWORD_LENGTH))
    {
      if (connect_wifi(eeprom_ssid, eeprom_password))
      {
        connect_mqtt();
        return;
      }
    }
    // keine WLAN-DAten gefunden
    setup_ap();
  }
\end{lstlisting}
\begin{lstlisting}[frame=single, style=cpp, numbers=left, label={lst:esp8266validstring}, caption={ESP: is\_valid\_string}]
  bool is_valid_string(char *data, int max_length)
  {
    if (strlen(data) == 0 or strlen(data) > max_length)
      return false;
    for (int i = 0; i < max_length; i++)
    {
      if (data[i] == '\0')
        return true; // End of valid String
      if (data[i] == 0xFF) // Default EEPROM
        return false;
    }
    return false;
  }
\end{lstlisting}
\begin{lstlisting}[frame=single, style=cpp, numbers=left, label={lst:espconnectwifi}, caption={ESP: connect\_wifi}]
  bool connect_wifi(char *ssid, char *password)
  {
    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);
  
    for (uint8_t i = 0; i < wifi_repeat; i++)
    {
      if (WiFi.status() == WL_CONNECTED)
      {
        Serial.println(WiFi.localIP());
        return true;
      }
      delay(1000);
    }
    return false;
  }
\end{lstlisting}
\begin{lstlisting}[frame=single, style=cpp, numbers=left, label={lst:espconnectmqtt}, caption={ESP: connect\_mqtt}]
  void mqtt_connect()
  {
    set_topics();
    mqttClient.setServer(MQTT_BROKER_ADRRESS, MQTT_PORT);
    mqttClient.setCallback(callback);
    for (int i = 0; i < wifi_repeat; i++)
    {
      if (mqttClient.connect(DEVICE_ID))
        mqttClient.subscribe(SUBSCRIBE_TOPIC);
        return;
      else
        delay(1000);
    }
  }
\end{lstlisting}
\begin{lstlisting}[frame=single, style=cpp, numbers=left, label={lst:espsettopics}, caption={ESP: set\_topics}]
  void set_topics()
  {
    SUBSCRIBE_TOPIC = (char *)malloc(strlen(TOPIC_COMMAND) + strlen(DEVICE_ID) + 2);
    PUBLISH_TOPIC = (char *)malloc(strlen("data") + strlen(DEVICE_ID) + 2);
  
    strcpy(SUBSCRIBE_TOPIC, TOPIC_COMMAND);
    strcat(SUBSCRIBE_TOPIC, "/");
    strcat(SUBSCRIBE_TOPIC, DEVICE_ID);
  
    strcpy(PUBLISH_TOPIC, "data");
    strcat(PUBLISH_TOPIC, "/");
    strcat(PUBLISH_TOPIC, DEVICE_ID);
  }
\end{lstlisting}
\begin{lstlisting}[frame=single, style=cpp, numbers=left, label={lst:esp8266defap}, caption={ESP8266: ap\_konfiguration}]
  const char AP_SSID[] = "ESP8266";
  const char AP_PASSWORD[] = "setupesp";
  IPAddress ap_ip(10, 0, 0, 1);
  IPAddress ap_gateway(10, 0, 0, 1);
  IPAddress ap_subnet(255, 255, 255, 0);
  AsyncWebServer server(80);
  const String html_page = R"rawliteral(
    <html>
    <body>
      <h2>Wi-Fi Configuration</h2>
      <form action="/save" method="POST">
        SSID:<br>
        <input type="text" name="ssid" required><br>
        Password:<br>
        <input type="password" name="password" required><br><br>
        <input type="submit" value="Submit">
      </form>
    </body>
    </html>
  )rawliteral";
\end{lstlisting}
\begin{lstlisting}[frame=single, style=cpp, numbers=left, label={lst:esp8266setupap}, caption={ESP: setup\_ap}]
  void setup_ap()
  {
    WiFi.mode(WIFI_AP);
    WiFi.softAP(AP_SSID, AP_PASSWORD);
    WiFi.softAPConfig(ap_ip, ap_gateway, ap_subnet);
  
    server.on("/", HTTP_GET, [](AsyncWebServerRequest *request)
              { request->send(200, "text/html", html_page); });
  
    server.on("/save", HTTP_POST, [](AsyncWebServerRequest *request)
              {
                // get input data
                String ssid = request->getParam("ssid", true)->value();
                String password = request->getParam("password", true)->value();
                if (ssid.length() > MAX_SSID_LENGTH - 1 || password.length() > MAX_PASSWORD_LENGTH - 1)
                {
                  return;
                }
                // String in char[]
                char new_ssid[MAX_SSID_LENGTH] = {0};
                strncpy(new_ssid, ssid.c_str(), MAX_SSID_LENGTH - 1);
                char new_password[MAX_PASSWORD_LENGTH] = {0};
                strncpy(new_password, password.c_str(), MAX_PASSWORD_LENGTH - 1);
  
                // in EEPROM speichern
                EEPROM.begin(128);
                EEPROM.put(0, new_ssid);
                EEPROM.put(32, new_password);
                EEPROM.commit();
                EEPROM.end();
  
                request->send(200, "text/html", "WiFi saved. Rebooting...");
                ESP.restart(); });
  
    server.begin();
  }
\end{lstlisting}
  \subsubsection{ESP8266}
  \par Der ESP8266 wird für die Verbindung des Arduinos mit dem WLAN verwendet. Zu seinem Aufgaben gehört das Senden und Empfangen der MQTT-Nachrichten in entsprechenden Topics. Wie in meinem Bericht zur Projektarbeit 2 \cite{pa2} Kapitel 4.1 beschrieben, ist der ESP8266 über eine UART-Schnittstelle mit dem Arduino verbunden.
  \par Beim Start des Moduls wird die Funktion \texttt{setup()} (Listing \ref{lst:esp8266setup}) ausgeführt. Zusätzlich läuchtet der blaue LED während der Einrichtung des Moduls. Der Diode läuchtet, wenn es keine Spannung auf dem GPIO 1 fällt.
  % \begin{lstlisting}[frame=single, style=cpp, numbers=left, label={lst:esp8266led}, caption={ESP: LED}]
  \begin{Verbatim}[frame=single]
    digitalWrite(1, LOW);   // Diode einschalten
    digitalWrite(1, HIGH);  // Diode ausschalten
  \end{Verbatim}
  \par Nach der erfolgreichen Einrichtung und Verbindung mit dem WLAN sowie MQTT-Broker, schaltet der Diode aus. Bei jedem Pogrammdurchlauf wird die Funktion \texttt{readSerialData} (Listing \ref{lst:esp8266readserial}) aufgerufen. Stehen die Daten in der seriellen Schnittstelle zur Verfügung, werden diese zunächst als String ausgelesen und gespeichert. Der String wird auf ihre maximale Länge geprüft. Anschließend muss der String in ein char-Feld konvertiert werden. Um das Topic und den Text der Nachrichten zuzuordnen, wird nach der Position von „:“ gesucht. Alle Zeichen rechts von „:“ gehören zum Text der Nachricht und werden in der Variablen „\texttt{message}“ gespeichert. Aus den Zeichen links von „:“ wird das Topic gebildet. Arduino überträgt nur die Namen der Haupttopics. Das ESP8266 erweitert das von Arduino übergebene Topic mit der ID des Gerätes und formuliert das \texttt{PUBLISH\_TOPIC} (Zeile 22-32). Wenn das Topic aus irgendeinem Grund nicht korrekt formuliert werden kann, wird die Nachricht im Haupttopic gesendet. Damit ist sichergestellt, dass die Nachricht versendet wird. Sobald das ESP8266 die Daten von dem Arduino empfängt, wird die MQTT-Nachricht an den MQTT-Broker mit dem Befehl „\texttt{mqttClient.publish(topic, message)}“ versandt.
  \par Die Verarbeitung der empfangenen Nachricht erfolgt in der Funktion \texttt{callback} (Listing \ref{lst:espcallback}). Der ESP8266 abonniert nur das Topic, das in der Variablen \texttt{SUBSCRIBE\_TOPIC} definiert ist. Beim Empfang der Nachricht aus dem Topic wird geprüft, ob die Nachricht aus dem dem Gerät zugewiesenen Topic stammt. Wenn dies der Fall ist, wird der Text der Nachricht über Serial an Arduino gesendet.
  \begin{lstlisting}[frame=single, style=cpp, numbers=left, label={lst:esp8266readserial}, caption={ESP8266: readSerialData}]
    void readSerialData()
    {
      if (Serial.available() > 0)
      {
        String readString = "";
        // Lese Daten aus Serial als String ab
        readString = Serial.readStringUntil('\n');
        if (sizeof(readString) > buss_serial)
          return;
        // String in char-Feld konvertieren
        char readSerialChar[readString.length() + 1];
        readString.toCharArray(readSerialChar, readString.length() + 1);    
        // Suche Position von ':'
        char *delim_pos = strchr(readSerialChar, ':');
        if (delim_pos != NULL)
        {
          size_t topic_length = delim_pos - readSerialChar;
          char topic[topic_length + 1];
          strncpy(topic, readSerialChar, topic_length);
          topic[topic_length] = '\0';
          char *message = delim_pos + 1;
          PUBLISH_TOPIC = (char *)malloc(strlen(CLIENT_ID) + strlen(topic) + 2);
          if (PUBLISH_TOPIC == NULL)
          {
            PUBLISH_TOPIC = topic;
          }
          else
          {
            strcpy(PUBLISH_TOPIC, topic);
            strcat(PUBLISH_TOPIC, "/");
            strcat(PUBLISH_TOPIC, CLIENT_ID);
          }
          // MQTT-Nachricht senden
          mqttClient.publish(PUBLISH_TOPIC, message);
        }
        else // kein : gefunden
          return;
      }
    }
  \end{lstlisting}

  \begin{lstlisting}[frame=single, style=cpp, numbers=left, label={lst:esp8266callback}, caption={ESP8266: callback}]
    void callback(char *topic, byte *payload, unsigned int length)
    {
      String id = String(topic).substring(String(topic).indexOf('/') + 1);
      if (id == CLIENT_ID)
      {
        String text = "";
        for (int i = 0; i < length; i++)
        {
          text += (char)payload[i];
        }
        text.trim();
        // Print in Arduino
        Serial.println(text);
      }
    }
  \end{lstlisting}
  
  \subsubsection{M5Stick}
  \par Der M5Stick wird zur Überwachung der Licht- und Luftbedingungen eingesetzt. Die Idee ist, dass der Sensor die aktuelle Wetterbedingungen überwacht und diese an dem Server sendet. Für diesen Zweck soll der Sensor an dem Fenster draußen positioniert werden.
  \par Am Modul sind die Sensoren BME680 und VCNL4040 angebunden. Der BME680 erfasst Umweltdaten: Temperatur, Luftfeuchtigkeit und Gaswiderstand. Der VCNL4040 dient als Lichtsensor und misst Lichtbedingungen: Umgebungshelligkeit (Ambient Light), weißes Licht sowie Annäherung (Proximity). Diese Daten werden an dem Server via MQTT-Nachrichten gesendet.
  \par Für die Verwendung der beiden Sensoren im Programmcode müssen die entsprechenden Bibliotheken importiert werden und die Klassenobjekten für die Sensoren erstellt werden (Listing \ref{lst:m5sensoren}). 
\begin{lstlisting}[frame=single, style=cpp, numbers=left, label={lst:m5sensoren}, caption={M5Stick: Sensoren}]
  #include <Adafruit_BME680.h>
  #include <Adafruit_VCNL4040.h>
  Adafruit_BME680 bme_sensor;
  Adafruit_VCNL4040 vcnl4040 = Adafruit_VCNL4040();
\end{lstlisting}

\par Beim Start des Moduls wird die Funktion \texttt{setup()} aufgerufen. Zusätzlich zu der im Listing \ref{lst:esp8266setup} duchgeführte Einrichtungen müssen noch die beiden Sensoren eingerichted und im Betriebszustand gebracht werden. Dacher werden im Setup die Funktionen \texttt{vcnl\_setup()} und \texttt{bme\_setup()} für die Einrichtung der Sensoren aufgerufen.

\begin{lstlisting}[frame=single, style=cpp, numbers=left, label={lst:m5vcnlsetup}, caption={M5Stick: vcnl\_setup}]

\end{lstlisting}

\subsubsection{ESP32}

\subsection{Softwareentwicklung}
\par 
  \subsubsection{Webserver}
  \subsubsection{Datenbank}
  \subsubsection{Frontend}
  \subsubsection{Integration der Komponenten}
  \par MQtt client, erhalten Daten von Broker etc

\newpage
\section{Ergebnisse und Diskussion}

\newpage
\section{Quellen}
\begin{thebibliography}{20}
  \bibitem{pa1}
  O. Baida,
  \textit{Anbindung der Sensoren und Aktoren an den Arduino zur Realisierung eines Sicherheitssystems},
  Projektarbeit 1, 2024.

  \bibitem{pa2}
  O. Baida, Projektarbeit 2 \textit{Sicherheitssystem fur das Haus basierend auf Arduino, ESP8266 \& Raspberry Pi} \url{https://github.com/oleksiibaida/PA2.git}
  \bibitem{video}
  
  \bibitem{statita_smhomes}
  Statista, \textit{„Smart Home - Anzahl der Haushalte in Deutschland 2028“}, Zugegriffen: 13. Januar 2025. [Online]. Verfügbar unter \url{https://de.statista.com/prognosen/885611/anzahl-der-smart-home-haushalte-in-deutschland}
  \bibitem{spiegel_heizung}
  J. Breithut, \textit{„Strom und Heizung: Wann ein Smart Home wirklich beim Energiesparen hilft“}, Der Spiegel, 17. Juli 2022. Zugegriffen: 13. Januar 2025. [Online]. Verfügbar unter: \url{https://www.spiegel.de/netzwelt/gadgets/strom-und-heizung-wann-ein-smart-home-wirklich-beim-energiesparen-hilft-a-ffb4b710-0cec-40e4-a2c4-6c5d4a3feb92}


  \par \textbf{Links zur verwendeten Hardware:}
  \bibitem{arduino}
  Arduino.cc, \textit{Arduino UNO}, \url{https://docs.arduino.cc/hardware/uno-rev3/}
  \bibitem{raspi}
  Raspberry Pi Foundation, \textit{Raspberry Pi 1 B+}, \url{https://www.raspberrypi.com/products/raspberry-pi-1-model-b-plus/}
  \bibitem{esp8266}
  Espressif, \textit{ESP8266}, \url{https://www.espressif.com/}, \url{https://www.electronicwings.com/sensors-modules/esp8266-wifi-module}
  \par \textbf{Links zur verwendeten Software:}
  \bibitem{mqtt}
  Dr Andy Stanford-Clark, Arlen Nipper, \textit{Message Queuing Telemetry Transport}, \url{https://mqtt.org/}
  \bibitem{python}
  Guido van Rossum, Python Software Foundation, \textit{Python}, \url{https://www.python.org/}
  \bibitem{telegram}
  Telegram FZ-LLC, \textit{Telegram Messenger}, \url{https://github.com//telegramdesktop/tdesktop}
  \par \textbf{Linux-Packete}:
  \bibitem{hostapd}
  Jouni Malinen, \textit{hostapd}, \url{https://w1.fi/hostapd/}, Zugriff am: 19. September 2024.
  \bibitem{dnsmasq}
  Simon Kelley, \textit{dnsmasq}, \url{https://dnsmasq.org/doc.html}, Zugriff am: 20. September 2024.
  \bibitem{mosquitto}
  Eclipse Foundation, \textit{Eclipse Mosquitto}, \url{https://mosquitto.org/}
  \par \textbf{ESP- und Arduino-Bibliotheken}
  \bibitem{pubsub} 
  Knolleary, \textit{PubSubClient}, \url{https://pubsubclient.knolleary.net/}, Zugriff am: 21. Oktober 2024.
  \bibitem{espwifi}
  ESPWIFI.h, \url{https://arduino-esp8266.readthedocs.io/en/latest/esp8266wifi/readme.html}
  \bibitem{eeprom}
  EEPROM.h, \url{https://docs.arduino.cc/learn/built-in-libraries/eeprom/}
  \bibitem{keypad}
  Keypad.h \url{https://docs.arduino.cc/libraries/keypad/}
  \bibitem{scholz}
  R. Scholz, \textit{Syncloop}, Persönliche Mitteilungen
  \par \textbf{Python-Bibliotheken}
  \bibitem{paho}
  Pierre Fersing, Roger Light \textit{paho-mqtt}, \url{https://pypi.org/project/paho-mqtt/}, Zugriff am: 21. Oktober 2024.
  \bibitem{tgbot}
  Open Source, \textit{python-telegram-bot}, \url{https://docs.python-telegram-bot.org/en/v21.6/}
  \bibitem{json}
  Python Software Foundation, \textit{json}, \url{https://docs.python.org/3/library/json.html}
  \bibitem{threading}
  Python Software Foundation, \textit{threading}, \url{https://docs.python.org/3/library/threading.html}
  \bibitem{queue}
  Python Software Foundation, \textit{queue}, \url{https://docs.python.org/3/library/queue.html}
  \bibitem{sqlite}
  Gerhard Häring, \textit{sqlite3}, \url{https://docs.python.org/3/library/sqlite3.html}
  \bibitem{pyzbar}
  Lawrence Hudson, \textit{pyzbar}, \url{https://github.com/NaturalHistoryMuseum/pyzbar/}
  \bibitem{cv2}
  Intel, \textit{OpenCV}, \url{https://github.com/opencv/opencv-python}
  \bibitem{aiohttp}
  Aio-Libs, \textit{aiohttp}, \url{https://github.com/aio-libs/aiohttp}
\end{thebibliography}



\listoffigures
\addcontentsline{toc}{section}{Abbildungsverzeichnis}

\listoftables
%\addcontentsline{toc}{section}{Tabellenverzeichnis}
\lstlistoflistings
\addcontentsline{toc}{section}{Programmcode}



\end{document}
% „“